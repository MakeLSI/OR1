# lef conversion program by Seijiro Moriyama (May 13, 2018)
# rev. 2 (Aug 2, 2019)
# works only for ones generated by ALSI Yamdada-san
require 'byebug'

$direction={}
cell = nil
lef_cells = []
File.read(File.join(File.dirname(__FILE__),'./OR1_stdcells.lib')).each_line{|l|
#  puts l
  l.sub!("\r", '')
  if l=~/cell\((\S+)\)/
    cell = $1
    $direction[cell]={}
    lef_cells << cell
  elsif l=~/pin\((\S+)\).*direction: *(\S+);/
#    puts $1, $2
    $direction[cell][$1] = $2.upcase
  end
}
# debugger

def read_lef lines
  pl = nil 
  cell = nil
  pin = nil 
  ports = {}
  flag_pin = false
  width = nil
  layer = nil
  lines.each_line{|l|
    l.sub!("\r", '')
    if flag_pin
      if pl=~/USE SIGNAL/ 
        puts "    USE SIGNAL ;\n"
      elsif pl =~ /LAYER (\S+)/
        layer = $1
        ports[layer] = []
      elsif pl=~/(PATH|POLYGON)[^;]*$/
          ports[layer] << pl.chomp + l.strip.sub(/  ;$/, ' ;') + "\n"
          l = nil
      elsif pl=~/(RECT |PATH |POLYGON )/
        ports[layer] << pl.sub(/ +;$/, ' ;')
      elsif pl=~/WIDTH +(\S+)/
        ports[layer] << pl.sub(/  ;$/, ' ;')
      elsif pl=~ /PORT/
      # do nothing
      elsif pl=~/END *#{pin}/
        puts '    PORT'
        ports.each_pair{|layer, geoms|
          puts "      LAYER #{layer} ;"
          geoms.each{|g|
            if g =~ /WIDTH +(\S+)/
              width = $1
            else
              print_geom g, width
            end
          }
        }
        puts '    END'
        ports = {}
        puts pl
        flag_pin = false
      elsif pl=~ /END/       # do nothing
      else
        puts pl.sub(/  ;$/, ' ;') if pl       
      end
    elsif pl=~/MACRO *(\S+)/
      cell = $1
      puts pl
    elsif pl=~/PIN *(\S+)/
      pin = $1 
      puts pl
      # puts "cell:#{cell}, pin:#{pin}"
      dir = $direction[cell][pin] || 'INOUT' # for vdd, gnd, etc. 
      puts "    DIRECTION #{dir} ;" if dir
      flag_pin = true
    elsif pl =~ /(PATH|POLYGON)[^;]*$/
      print_geom pl.chomp + l.strip.sub(/ +;$/, ' ;') + "\n", width, 6
      l = nil
    elsif pl =~ /(PATH|RECT|POLYGON)/
      print_geom pl, width, 6
    elsif pl =~ /WIDTH +(\S+)/
      width = $1
    else
      puts pl if pl
    end
    pl = l
  }
  puts pl
end

def print_geom g, width, leading_spaces=8
  if g =~ /PATH +(\S+) +(\S+) +(\S+) +(\S+) +(.*);/
    x1=$1
    y1=$2
    x2=$3
    y2=$4
    rest = $5.strip
    print ' '*leading_spaces
    puts path2rect(width, x1, y1, x2, y2)
    x1 = x2
    y1 = y2
    while rest.size > 0
      rest =~ /(\S+) +(\S+) *(.*)/
      x2 = $1
      y2 = $2
      rest = $3
      print ' '*leading_spaces
      puts path2rect(width, x1, y1, x2, y2)
      x1 = x2
      y1 = y2
    end
  else
    puts g
  end
end  

def path2rect width, x1, y1, x2, y2
  if y1 == y2
    xll = x1.to_f
    yll = y1.to_f - width.to_f/2.0
    xur = x2.to_f
    yur = y1.to_f + width.to_f/2.0
  elsif x1 == x2
    xll = x1.to_f - width.to_f/2.0
    yll = y1.to_f
    xur = x1.to_f + width.to_f/2.0
    yur = y2.to_f
  end
  "RECT #{[xll, xur].min.round(2)} #{[yll, yur].min.round(2)} #{[xll, xur].max.round(2)} #{[yll, yur].max.round(2)} ;"
end

def extract_macro name, lines 
  result = nil
  lines.each_line{|l|
    if result
      result << l
      break if l=~/END +#{name}/
    elsif l =~ /MACRO +#{name}/
      result = l
    end
  }
  result
end

if ARGV[0].nil?
  lines =<<EOF
        WIDTH 1.000 ;
        PATH 4.800 20.500 4.800 18.000 ;
EOF
  
  puts path_to_rect(lines)
  
  debugger
  
  lines =<<EOF
        WIDTH 1.000 ;
        PATH 4.800 20.500 4.800 18.000 7.500 18.000 7.500 6.500 6.800 6.500 6.800 3.800 ;
EOF
  
  puts path_to_rect(lines)
  
  debugger
end

if File.directory? ARGV[0]
  merged = File.join(File.dirname(__FILE__), File.basename(ARGV[0])+'_merged.lef')
  File.open(merged, 'w'){|f|
    lef_cells.each{|lef|
      lines = File.read(File.join ARGV[0], lef+'.lef')
      lines = extract_macro lef, lines
      read_lef lines
      f.puts lines
    }
  }
#  puts "'#{merged}' created"
else
  lines = File.read(ARGV[0])
#  lines = extract_macro 'an21', lines
  read_lef lines
end
